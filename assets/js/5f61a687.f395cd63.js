"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[83992],{58611:function(e,n,t){t.r(n),t.d(n,{assets:function(){return f},contentTitle:function(){return h},default:function(){return b},frontMatter:function(){return u},metadata:function(){return p},toc:function(){return m}});var i=t(83117),a=t(80102),r=(t(67294),t(3905)),o=t(76018),s=t(71871),l=t(74606),d=t(8813),c=["components"],u={title:"Verifiable Presentations",sidebar_label:"Verifiable Presentations",description:"Explain how a VC is created and verified",image:"/img/Identity_icon.png",keywords:["verifiable","presentations"]},h=void 0,p={unversionedId:"verifiable_credentials/verifiable_presentations",id:"verifiable_credentials/verifiable_presentations",title:"Verifiable Presentations",description:"Explain how a VC is created and verified",source:"@site/external/identity.rs/documentation/docs/verifiable_credentials/verifiable_presentations.mdx",sourceDirName:"verifiable_credentials",slug:"/verifiable_credentials/verifiable_presentations",permalink:"/identity.rs/verifiable_credentials/verifiable_presentations",editUrl:"https://github.com/iotaledger/identity.rs/edit/dev/external/identity.rs/documentation/docs/verifiable_credentials/verifiable_presentations.mdx",tags:[],version:"current",frontMatter:{title:"Verifiable Presentations",sidebar_label:"Verifiable Presentations",description:"Explain how a VC is created and verified",image:"/img/Identity_icon.png",keywords:["verifiable","presentations"]},sidebar:"docs",previous:{title:"Revocation",permalink:"/identity.rs/verifiable_credentials/revoke"},next:{title:"Overview",permalink:"/identity.rs/did_communications/overview"}},f={},m=[{value:"Example",id:"example",level:2},{value:"Account Module (Recommended)",id:"account-module-recommended",level:3},{value:"Low-level API",id:"low-level-api",level:3}],v={toc:m};function b(e){var n=e.components,t=(0,a.Z)(e,c);return(0,r.kt)("wrapper",(0,i.Z)({},v,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"TODO: Explain the need for and"),(0,r.kt)("h2",{id:"example"},"Example"),(0,r.kt)("p",null,"This example shows how you can create and validate a Verifiable Presentation. A Verifiable Presentation is the format in which you can share a (collection of) Verifiable Credential(s). It is signed by the subject, to prove control over the Verifiable Credential with a nonce or timestamp."),(0,r.kt)("h3",{id:"account-module-recommended"},"Account Module (Recommended)"),(0,r.kt)(l.Z,{className:"language-rust",mdxType:"CodeBlock"},d.Z),(0,r.kt)("h3",{id:"low-level-api"},"Low-level API"),(0,r.kt)(o.Z,{groupId:"programming-languages",defaultValue:"rust",values:[{label:"Rust",value:"rust"},{label:"Node.js",value:"nodejs"}],mdxType:"Tabs"},(0,r.kt)(s.Z,{value:"rust",mdxType:"TabItem"},(0,r.kt)(l.Z,{className:"language-rust",mdxType:"CodeBlock"},'// Copyright 2020-2022 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\n//! A Verifiable Presentation (VP) represents a bundle of one or more Verifiable Credentials.\n//! This example demonstrates building and usage of VPs.\n//!\n//! cargo run --example create_vp\n\nuse identity::core::Duration;\nuse identity::core::FromJson;\nuse identity::core::Timestamp;\nuse identity::core::ToJson;\nuse identity::core::Url;\nuse identity::credential::Credential;\nuse identity::credential::Presentation;\nuse identity::credential::PresentationBuilder;\nuse identity::crypto::ProofOptions;\nuse identity::did::verifiable::VerifierOptions;\n\nuse identity::iota::CredentialValidationOptions;\nuse identity::iota::FailFast;\nuse identity::iota::PresentationValidationOptions;\nuse identity::iota::Receipt;\nuse identity::iota::Resolver;\nuse identity::iota::SubjectHolderRelationship;\nuse identity::prelude::*;\n\nmod common;\nmod create_did;\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n  // ===========================================================================\n  // Participants: credential issuer, presentation holder, verifier\n  // ===========================================================================\n\n  // Create a signed DID Document/KeyPair for the credential issuer (see create_did.rs).\n  let (doc_iss, key_iss, _): (IotaDocument, KeyPair, Receipt) = create_did::run().await?;\n\n  // Create a signed DID Document/KeyPair for the credential subject (see create_did.rs).\n  let (doc_sub, key_sub, _): (IotaDocument, KeyPair, Receipt) = create_did::run().await?;\n\n  // Note that in this example the credential subject is the same as the holder of the presentation.\n\n  // The verifier asks the holder for a presentation signed with the following challenge:\n  let challenge: &str = "475a7984-1bb5-4c4c-a56f-822bccd46440";\n  // The verifier and holder also agree that the signature should have an expiry date\n  // 10 minutes from now.\n\n  // A unique random challenge generated by the requester per presentation can mitigate replay attacks\n  // (along with other properties like `expires` and `domain`).\n\n  // ===========================================================================\n  // Issuer - creates and issues a verifiable credential to the holder.\n  // ===========================================================================\n\n  // Create an unsigned Credential with claims about `subject` specified by `issuer`.\n  let mut credential: Credential = common::issue_degree(&doc_iss, &doc_sub)?;\n\n  // Sign the Credential with the issuers private key.\n  doc_iss.sign_data(\n    &mut credential,\n    key_iss.private(),\n    doc_iss.default_signing_method()?.id(),\n    ProofOptions::default(),\n  )?;\n\n  println!("Credential JSON > {:#}", credential);\n\n  // The credential is then serialized to JSON and transmitted to the holder in a secure manner.\n  // Note that the credential is NOT published to the IOTA Tangle. It is sent and stored off-chain.\n  let credential_json: String = credential.to_json()?;\n\n  // ===========================================================================\n  // Holder - creates a verifiable presentation from the issued credential for the verifier to validate.\n  // ===========================================================================\n\n  // Deserialize the credential.\n  let credential: Credential = Credential::from_json(credential_json.as_str())?;\n\n  // Create an unsigned Presentation from the previously issued Verifiable Credential.\n  let mut presentation: Presentation = PresentationBuilder::default()\n    .id(Url::parse("asdf:foo:a87w3guasbdfuasbdfs")?)\n    .holder(Url::parse(doc_sub.id().as_ref())?)\n    .credential(credential)\n    .build()?;\n\n  // The holder signs the presentation with their private key and includes the requested challenge and an expiry\n  // timestamp.\n  doc_sub.sign_data(\n    &mut presentation,\n    key_sub.private(),\n    doc_sub.default_signing_method()?.id(),\n    ProofOptions::new()\n      .challenge(challenge.to_string())\n      .expires(Timestamp::now_utc().checked_add(Duration::minutes(10)).unwrap()),\n  )?;\n\n  // Convert the Verifiable Presentation to JSON to send it to the verifier.\n  let presentation_json: String = presentation.to_json()?;\n\n  // ===========================================================================\n  // Verifier - receives a verifiable presentation from the holder and validates it.\n  // ===========================================================================\n\n  // Deserialize the presentation from the holder:\n  let presentation: Presentation = Presentation::from_json(&presentation_json)?;\n\n  // The verifier wants the following requirements to be satisfied:\n  // - Signature verification (including checking the requested challenge to mitigate replay attacks)\n  // - Presentation validation must fail if credentials expiring within the next 10 hours are encountered\n  // - The presentation holder must always be the subject, regardless of the presence of the nonTransferable property\n  // - The issuance date must not be in the future.\n\n  let presentation_verifier_options: VerifierOptions = VerifierOptions::new()\n    .challenge(challenge.to_owned())\n    .allow_expired(false);\n\n  // Do not allow credentials that expire within the next 10 hours.\n  let credential_validation_options: CredentialValidationOptions = CredentialValidationOptions::default()\n    .earliest_expiry_date(Timestamp::now_utc().checked_add(Duration::hours(10)).unwrap());\n\n  let presentation_validation_options = PresentationValidationOptions::default()\n    .presentation_verifier_options(presentation_verifier_options.clone())\n    .shared_validation_options(credential_validation_options)\n    .subject_holder_relationship(SubjectHolderRelationship::AlwaysSubject);\n\n  // Validate the presentation and all the credentials included in it.\n  let resolver: Resolver = Resolver::new().await?;\n  resolver\n    .verify_presentation(\n      &presentation,\n      &presentation_validation_options,\n      FailFast::FirstError,\n      None,\n      None,\n    )\n    .await?;\n\n  // Note that we did not declare a latest allowed issuance date for credentials. This is because we only want to check\n  // that the credentials do not have an issuance date in the future which is a default check.\n\n  Ok(())\n}\n')),(0,r.kt)(s.Z,{value:"nodejs",mdxType:"TabItem"},(0,r.kt)(l.Z,{className:"language-javascript",mdxType:"CodeBlock"},'// Copyright 2020-2021 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n    Credential,\n    CredentialValidationOptions,\n    Duration,\n    FailFast,\n    Presentation,\n    PresentationValidationOptions,\n    ProofOptions,\n    Resolver,\n    SubjectHolderRelationship,\n    Timestamp,\n    VerifierOptions\n} from \'@iota/identity-wasm\';\nimport {createVC} from \'./create_vc\';\n\n/**\n This example shows how to create a Verifiable Presentation and validate it.\n A Verifiable Presentation is the format in which a (collection of) Verifiable Credential(s) gets shared.\n It is signed by the subject, to prove control over the Verifiable Credential with a nonce or timestamp.\n\n @param {{network: Network, explorer: ExplorerUrl}} clientConfig\n **/\nasync function createVP(clientConfig) {\n    // An issuer creates and signs a Verifiable Credential and passes it to the credential subject `Alice`.\n\n    // See "createVC" example\n    const {alice, credentialJSON} = await createVC(clientConfig);\n\n    // In this example the credential subject Alice will be the presentation holder.\n\n    // ===========================================================================\n    // Holder - creates a verifiable presentation from the issued credential for the verifier to validate.\n    // ===========================================================================\n\n    // Deserialize the credential.\n    const signedVc = Credential.fromJSON(credentialJSON);\n\n    // Create a Verifiable Presentation from the Credential\n    const unsignedVp = new Presentation(alice.doc, signedVc.toJSON())\n\n    // The verifier has asked Alice for a presentation signed with the following challenge:\n    const challenge = "475a7984-1bb5-4c4c-a56f-822bccd46440";\n    // The verifier and holder also agree that the signature should have an expiry date\n    // 10 minutes from now.\n\n    // A unique random challenge generated by the requester per presentation can mitigate replay attacks\n    // (along with other properties like `expires` and `domain`).\n\n    // Sign the verifiable presentation with the holder\'s private key and include the requested challenge and expiry timestamp.\n    const signedVp = alice.doc.signPresentation(unsignedVp,\n        alice.key.private(),\n        "#sign-0",\n        new ProofOptions({\n            challenge: challenge,\n            expires: Timestamp.nowUTC().checkedAdd(Duration.minutes(10))\n        }));\n\n    // Convert the Verifiable Presentation to JSON to send it to the verifier.\n    const signedVpJSON = signedVp.toJSON();\n\n\n    // ===========================================================================\n    // Verifier - receives a verifiable presentation from the holder and validates it.\n    // ===========================================================================\n\n    // Deserialize the presentation from the holder.\n    const presentation = Presentation.fromJSON(signedVpJSON);\n\n    // The verifier wants the following requirements to be satisfied:\n    // - Signature verification (including checking the requested challenge to mitigate replay attacks)\n    // - Presentation validation must fail if credentials expiring within the next 10 hours are encountered\n    // - The presentation holder must always be the subject, regardless of the presence of the nonTransferable property\n    // - The issuance date must not be in the future.\n\n    // Declare that the challenge must match our expectation:\n    const presentationVerifierOptions = new VerifierOptions({\n        challenge: "475a7984-1bb5-4c4c-a56f-822bccd46440",\n        allowExpired: false,\n    });\n\n    // Declare that any credential contained in the presentation are not allowed to expire within the next 10 hours:\n    const earliestExpiryDate = Timestamp.nowUTC().checkedAdd(Duration.hours(10));\n    const credentialValidationOptions = new CredentialValidationOptions({\n        earliestExpiryDate: earliestExpiryDate,\n    });\n\n    // Declare that the presentation holder\'s DID must match the subject ID on all credentials in the presentation.\n    const subjectHolderRelationship = SubjectHolderRelationship.AlwaysSubject;\n\n    const presentationValidationOptions = new PresentationValidationOptions({\n        sharedValidationOptions: credentialValidationOptions,\n        presentationVerifierOptions: presentationVerifierOptions,\n        subjectHolderRelationship: subjectHolderRelationship,\n    });\n\n    // In order to validate presentations and credentials one needs to resolve the DID Documents of\n    // the presentation holder and of credential issuers. This is something the `Resolver` can help with.\n    const resolver = await Resolver\n        .builder()\n        .clientConfig({\n            network: clientConfig.network\n        })\n        .build();\n\n    // Validate the presentation and all the credentials included in it according to the validation options\n    await resolver.verifyPresentation(\n        presentation,\n        presentationValidationOptions,\n        FailFast.FirstError\n    );\n    // Since no errors were thrown by `verifyPresentation` we know that the validation was successful.\n    console.log(`VP successfully validated`);\n\n    // Note that the `verifyPresentation` method we called automatically resolved all DID Documents that are necessary to validate the presentation.\n    // It is also possible to supply extra arguments to avoid some resolutions if one already has up-to-date resolved documents of\n    // either the holder or issuers (see the method\'s documentation).\n}\n\nexport {createVP};\n'))))}b.isMDXComponent=!0},71871:function(e,n,t){t.d(n,{Z:function(){return a}});var i=t(67294);function a(e){var n=e.children,t=e.hidden,a=e.className;return i.createElement("div",{role:"tabpanel",hidden:t,className:a},n)}},76018:function(e,n,t){t.d(n,{Z:function(){return c}});var i=t(83117),a=t(67294),r=t(5730),o=t(10109),s=t(86010),l="tabItem_LplD";function d(e){var n,t,r,d=e.lazy,c=e.block,u=e.defaultValue,h=e.values,p=e.groupId,f=e.className,m=a.Children.map(e.children,(function(e){if((0,a.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),v=null!=h?h:m.map((function(e){var n=e.props;return{value:n.value,label:n.label,attributes:n.attributes}})),b=(0,o.lx)(v,(function(e,n){return e.value===n.value}));if(b.length>0)throw new Error('Docusaurus error: Duplicate values "'+b.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var g=null===u?u:null!=(n=null!=u?u:null==(t=m.find((function(e){return e.props.default})))?void 0:t.props.value)?n:null==(r=m[0])?void 0:r.props.value;if(null!==g&&!v.some((function(e){return e.value===g})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+g+'" but none of its children has the corresponding value. Available values are: '+v.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var y=(0,o.UB)(),w=y.tabGroupChoices,_=y.setTabGroupChoices,D=(0,a.useState)(g),V=D[0],k=D[1],x=[],C=(0,o.o5)().blockElementScrollPositionUntilNextRender;if(null!=p){var P=w[p];null!=P&&P!==V&&v.some((function(e){return e.value===P}))&&k(P)}var T=function(e){var n=e.currentTarget,t=x.indexOf(n),i=v[t].value;i!==V&&(C(n),k(i),null!=p&&_(p,i))},I=function(e){var n,t=null;switch(e.key){case"ArrowRight":var i=x.indexOf(e.currentTarget)+1;t=x[i]||x[0];break;case"ArrowLeft":var a=x.indexOf(e.currentTarget)-1;t=x[a]||x[x.length-1]}null==(n=t)||n.focus()};return a.createElement("div",{className:"tabs-container"},a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":c},f)},v.map((function(e){var n=e.value,t=e.label,r=e.attributes;return a.createElement("li",(0,i.Z)({role:"tab",tabIndex:V===n?0:-1,"aria-selected":V===n,key:n,ref:function(e){return x.push(e)},onKeyDown:I,onFocus:T,onClick:T},r,{className:(0,s.Z)("tabs__item",l,null==r?void 0:r.className,{"tabs__item--active":V===n})}),null!=t?t:n)}))),d?(0,a.cloneElement)(m.filter((function(e){return e.props.value===V}))[0],{className:"margin-vert--md"}):a.createElement("div",{className:"margin-vert--md"},m.map((function(e,n){return(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==V})}))))}function c(e){var n=(0,r.Z)();return a.createElement(d,(0,i.Z)({key:String(n)},e))}},8813:function(e,n){n.Z='// Copyright 2020-2022 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\n//! cargo run --example account_signing\n\nuse std::path::PathBuf;\n\nuse identity::account::Account;\nuse identity::account::IdentitySetup;\nuse identity::account::MethodContent;\nuse identity::account::Result;\nuse identity::account_storage::Stronghold;\nuse identity::core::json;\nuse identity::core::FromJson;\nuse identity::core::Url;\nuse identity::credential::Credential;\nuse identity::credential::Subject;\nuse identity::crypto::KeyPair;\nuse identity::crypto::ProofOptions;\nuse identity::did::verifiable::VerifierOptions;\nuse identity::did::DID;\nuse identity::iota::ExplorerUrl;\nuse identity::iota::ResolvedIotaDocument;\nuse identity::iota_core::IotaDID;\nuse identity::prelude::*;\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n  pretty_env_logger::init();\n\n  // ===========================================================================\n  // Create Identity - Similar to create_did example\n  // ===========================================================================\n\n  // Stronghold settings\n  let stronghold_path: PathBuf = "./example-strong.hodl".into();\n  let password: String = "my-password".to_owned();\n  let stronghold: Stronghold = Stronghold::new(&stronghold_path, password, None).await?;\n\n  // Create a new Account with stronghold storage.\n  let mut account: Account = Account::builder()\n    .storage(stronghold)\n    .create_identity(IdentitySetup::default())\n    .await?;\n\n  // ===========================================================================\n  // Signing Example\n  // ===========================================================================\n\n  // Add a new Ed25519 Verification Method to the identity\n  account\n    .update_identity()\n    .create_method()\n    .content(MethodContent::GenerateEd25519)\n    .fragment("key-1")\n    .apply()\n    .await?;\n\n  // Create a subject DID for the recipient of a `UniversityDegree` credential.\n  let subject_key: KeyPair = KeyPair::new(KeyType::Ed25519)?;\n  let subject_did: IotaDID = IotaDID::new(subject_key.public().as_ref())?;\n\n  // Create the actual Verifiable Credential subject.\n  let subject: Subject = Subject::from_json_value(json!({\n    "id": subject_did.as_str(),\n    "degree": {\n      "type": "BachelorDegree",\n      "name": "Bachelor of Science and Arts"\n    }\n  }))?;\n\n  // Issue an unsigned Credential...\n  let mut credential: Credential = Credential::builder(Default::default())\n    .issuer(Url::parse(account.did().as_str())?)\n    .type_("UniversityDegreeCredential")\n    .subject(subject)\n    .build()?;\n\n  // ...and sign the Credential with the previously created Verification Method\n  account.sign("key-1", &mut credential, ProofOptions::default()).await?;\n\n  println!("[Example] Local Credential = {:#}", credential);\n\n  // Fetch the DID Document from the Tangle\n  //\n  // This is an optional step to ensure DID Document consistency.\n  let resolved: ResolvedIotaDocument = account.resolve_identity().await?;\n\n  // Retrieve the DID from the newly created identity.\n  let iota_did: &IotaDID = account.did();\n\n  // Prints the Identity Resolver Explorer URL.\n  // The entire history can be observed on this page by clicking "Loading History".\n  let explorer: &ExplorerUrl = ExplorerUrl::mainnet();\n  println!(\n    "[Example] Explore the DID Document = {}",\n    explorer.resolver_url(iota_did)?\n  );\n\n  // Ensure the resolved DID Document can verify the credential signature\n  let verified: bool = resolved\n    .document\n    .verify_data(&credential, &VerifierOptions::default())\n    .is_ok();\n\n  println!("[Example] Credential Verified = {}", verified);\n\n  Ok(())\n}\n'}}]);